-- File: bench_divider.vhd
-- Generated by MyHDL 1.0dev
-- Date: Tue Jun 28 23:57:51 2016


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_10.all;

entity bench_divider is
end entity bench_divider;


architecture MyHDL of bench_divider is


signal operand: unsigned(9 downto 0);
signal result: unsigned(9 downto 0);
signal reset: std_logic;
signal clock: std_logic;
signal controlunit_1_opb: unsigned(3 downto 0);
signal controlunit_1_opa: unsigned(3 downto 0);
signal controlunit_1_sel: unsigned(1 downto 0);

procedure MYHDL4_mul(
    c: out unsigned;
    a: in unsigned;
    b: in unsigned) is
begin
    c <= (a * b);
end procedure MYHDL4_mul;

procedure MYHDL5_add(
    c: out unsigned;
    a: in unsigned;
    b: in unsigned) is
begin
    c <= (a + b);
end procedure MYHDL5_add;

procedure MYHDL6_sub(
    c: out unsigned;
    a: in unsigned;
    b: in unsigned) is
begin
    c <= (a - b);
end procedure MYHDL6_sub;

procedure MYHDL7_shift_l(
    c: out unsigned;
    a: in unsigned;
    b: in unsigned) is
begin
    c <= shift_left(a, b);
end procedure MYHDL7_shift_l;

begin




BENCH_DIVIDER_TBSTIM: process is
    variable L: line;
begin
    reset <= '1';
    wait for 40 * 1 ns;
    wait until rising_edge(clock);
    reset <= '0';
    operand <= to_unsigned(47, 10);
    wait until rising_edge(clock);
    wait until rising_edge(clock);
    write(L, to_string(to_integer(result)));
    writeline(output, L);
    operand <= to_unsigned(289, 10);
    wait until rising_edge(clock);
    wait until rising_edge(clock);
    write(L, to_string(to_integer(result)));
    writeline(output, L);
    operand <= to_unsigned(545, 10);
    wait until rising_edge(clock);
    wait until rising_edge(clock);
    write(L, to_string(to_integer(result)));
    writeline(output, L);
    operand <= to_unsigned(801, 10);
    wait until rising_edge(clock);
    wait until rising_edge(clock);
    write(L, to_string(to_integer(result)));
    writeline(output, L);
    assert False report "End of Simulation" severity Failure;
    wait;
end process BENCH_DIVIDER_TBSTIM;


controlunit_1_sel <= operand(10-1 downto 8);
controlunit_1_opa <= operand(8-1 downto 4);
controlunit_1_opb <= operand(4-1 downto 0);

BENCH_DIVIDER_CONTROLUNIT_1_ASSIGN2: process (clock, reset) is
begin
    if (reset = '1') then
    elsif rising_edge(clock) then
        case controlunit_1_sel is
            when "00" =>
                MYHDL4_mul(result, controlunit_1_opa, controlunit_1_opb);
            when "01" =>
                MYHDL5_add(result, controlunit_1_opa, controlunit_1_opb);
            when "10" =>
                MYHDL6_sub(result, controlunit_1_opa, controlunit_1_opb);
            when "11" =>
                MYHDL7_shift_l(result, controlunit_1_opa, controlunit_1_opb);
            when others =>
                null;
        end case;
    end if;
end process BENCH_DIVIDER_CONTROLUNIT_1_ASSIGN2;

BENCH_DIVIDER_TBCLOCK_1_CLOCKGEN: process is
begin
    clock <= '0';
    while True loop
        wait for 10 * 1 ns;
        clock <= stdl((not bool(clock)));
    end loop;
    wait;
end process BENCH_DIVIDER_TBCLOCK_1_CLOCKGEN;

end architecture MyHDL;
